
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>validator: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bargom/codeai/internal/validator/endpoint_validator.go (89.8%)</option>
				
				<option value="file1">github.com/bargom/codeai/internal/validator/errors.go (100.0%)</option>
				
				<option value="file2">github.com/bargom/codeai/internal/validator/event_validator.go (2.2%)</option>
				
				<option value="file3">github.com/bargom/codeai/internal/validator/symbol_table.go (100.0%)</option>
				
				<option value="file4">github.com/bargom/codeai/internal/validator/type_checker.go (97.4%)</option>
				
				<option value="file5">github.com/bargom/codeai/internal/validator/validator.go (47.8%)</option>
				
				<option value="file6">github.com/bargom/codeai/internal/validator/workflow_validator.go (1.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package validator provides endpoint validation for CodeAI AST.
package validator

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"

        "github.com/bargom/codeai/internal/ast"
)

// EndpointValidator performs semantic validation on endpoint declarations.
type EndpointValidator struct {
        errors      *ValidationErrors
        endpoints   map[string]*ast.EndpointDecl // key: method + path
        middlewares map[string]bool              // known middleware names
        types       map[string]bool              // known type names
        actions     map[string]bool              // known action names for logic steps
}

// NewEndpointValidator creates a new EndpointValidator instance.
func NewEndpointValidator() *EndpointValidator <span class="cov8" title="1">{
        return &amp;EndpointValidator{
                errors:      &amp;ValidationErrors{},
                endpoints:   make(map[string]*ast.EndpointDecl),
                middlewares: make(map[string]bool),
                types:       make(map[string]bool),
                actions:     make(map[string]bool),
        }
}</span>

// RegisterMiddleware registers a middleware as known/valid.
func (v *EndpointValidator) RegisterMiddleware(name string) <span class="cov8" title="1">{
        v.middlewares[name] = true
}</span>

// RegisterType registers a type as known/valid (for request/response type validation).
func (v *EndpointValidator) RegisterType(name string) <span class="cov8" title="1">{
        v.types[name] = true
}</span>

// RegisterAction registers an action as known/valid (for logic step validation).
func (v *EndpointValidator) RegisterAction(name string) <span class="cov8" title="1">{
        v.actions[name] = true
}</span>

// ValidateEndpoints validates a slice of endpoint declarations.
func (v *EndpointValidator) ValidateEndpoints(decls []*ast.EndpointDecl) error <span class="cov8" title="1">{
        for _, decl := range decls </span><span class="cov8" title="1">{
                v.validateEndpoint(decl)
        }</span>

        <span class="cov8" title="1">if v.errors.HasErrors() </span><span class="cov8" title="1">{
                return v.errors
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateEndpoint validates a single endpoint declaration.
func (v *EndpointValidator) validateEndpoint(decl *ast.EndpointDecl) <span class="cov8" title="1">{
        if decl == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Build unique key for endpoint (method + path)
        <span class="cov8" title="1">key := string(decl.Method) + " " + decl.Path

        // Check for duplicate endpoints
        if existing, exists := v.endpoints[key]; exists </span><span class="cov8" title="1">{
                v.errors.Add(newSemanticError(decl.Pos(),
                        fmt.Sprintf("duplicate endpoint %q; first declared at %s", key, existing.Pos().String())))
                return
        }</span>
        <span class="cov8" title="1">v.endpoints[key] = decl

        // Validate HTTP method
        v.validateHTTPMethod(decl)

        // Validate path
        v.validatePath(decl)

        // Validate middlewares
        v.validateMiddlewares(decl)

        // Validate annotations
        v.validateAnnotations(decl)

        // Validate handler
        v.validateHandler(decl)</span>
}

// validateHTTPMethod validates the HTTP method.
func (v *EndpointValidator) validateHTTPMethod(decl *ast.EndpointDecl) <span class="cov8" title="1">{
        validMethods := map[ast.HTTPMethod]bool{
                ast.HTTPMethodGET:    true,
                ast.HTTPMethodPOST:   true,
                ast.HTTPMethodPUT:    true,
                ast.HTTPMethodDELETE: true,
                ast.HTTPMethodPATCH:  true,
        }

        if !validMethods[decl.Method] </span><span class="cov8" title="1">{
                v.errors.Add(newSemanticError(decl.Pos(),
                        fmt.Sprintf("invalid HTTP method %q; valid methods: GET, POST, PUT, DELETE, PATCH", decl.Method)))
        }</span>
}

// validatePath validates the endpoint path.
func (v *EndpointValidator) validatePath(decl *ast.EndpointDecl) <span class="cov8" title="1">{
        path := decl.Path

        // Path must start with /
        if !strings.HasPrefix(path, "/") </span><span class="cov8" title="1">{
                v.errors.Add(newSemanticError(decl.Pos(),
                        fmt.Sprintf("endpoint path %q must start with '/'", path)))
        }</span>

        // Validate path parameters format
        <span class="cov8" title="1">pathParams := extractPathParams(path)
        seenParams := make(map[string]bool)
        for _, param := range pathParams </span><span class="cov8" title="1">{
                // Check for duplicate path parameters
                if seenParams[param] </span><span class="cov8" title="1">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("duplicate path parameter :%s in endpoint path %q", param, path)))
                }</span>
                <span class="cov8" title="1">seenParams[param] = true

                // Validate parameter name format
                if !isValidIdentifier(param) </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("invalid path parameter name :%s in endpoint path %q", param, path)))
                }</span>
        }

        // Validate path format (no double slashes, no trailing slash for non-root)
        <span class="cov8" title="1">if strings.Contains(path, "//") </span><span class="cov8" title="1">{
                v.errors.Add(newSemanticError(decl.Pos(),
                        fmt.Sprintf("endpoint path %q contains invalid double slashes", path)))
        }</span>

        // Warning for trailing slash (except root)
        <span class="cov8" title="1">if len(path) &gt; 1 &amp;&amp; strings.HasSuffix(path, "/") </span>{<span class="cov0" title="0">
                // This is a soft warning - not an error
        }</span>
}

// extractPathParams extracts parameter names from a path (e.g., "/users/:id" -&gt; ["id"])
var pathParamPattern = regexp.MustCompile(`:([a-zA-Z_][a-zA-Z0-9_]*)`)

func extractPathParams(path string) []string <span class="cov8" title="1">{
        matches := pathParamPattern.FindAllStringSubmatch(path, -1)
        params := make([]string, len(matches))
        for i, match := range matches </span><span class="cov8" title="1">{
                params[i] = match[1]
        }</span>
        <span class="cov8" title="1">return params</span>
}

// validateMiddlewares validates endpoint middlewares.
func (v *EndpointValidator) validateMiddlewares(decl *ast.EndpointDecl) <span class="cov8" title="1">{
        seenMiddlewares := make(map[string]bool)

        for _, mw := range decl.Middlewares </span><span class="cov8" title="1">{
                // Check for duplicate middleware usage
                if seenMiddlewares[mw.Name] </span><span class="cov8" title="1">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("duplicate middleware %q in endpoint %s %q", mw.Name, decl.Method, decl.Path)))
                }</span>
                <span class="cov8" title="1">seenMiddlewares[mw.Name] = true

                // Validate middleware name format
                if !isValidIdentifier(mw.Name) </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("invalid middleware name %q", mw.Name)))
                }</span>

                // Check if middleware is registered (if strict validation is enabled)
                <span class="cov8" title="1">if len(v.middlewares) &gt; 0 &amp;&amp; !v.middlewares[mw.Name] </span><span class="cov8" title="1">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("unknown middleware %q in endpoint %s %q", mw.Name, decl.Method, decl.Path)))
                }</span>
        }
}

// validateAnnotations validates endpoint annotations.
func (v *EndpointValidator) validateAnnotations(decl *ast.EndpointDecl) <span class="cov8" title="1">{
        seenAnnotations := make(map[string]bool)
        validAnnotations := map[string]bool{
                "deprecated":  true,
                "auth":        true,
                "rate_limit":  true,
                "cache":       true,
                "description": true,
                "summary":     true,
                "tag":         true,
                "version":     true,
                "internal":    true,
                "experimental": true,
        }

        for _, ann := range decl.Annotations </span><span class="cov8" title="1">{
                // Check for duplicate annotations (except for some that can repeat)
                repeatableAnnotations := map[string]bool{"tag": true}
                if seenAnnotations[ann.Name] &amp;&amp; !repeatableAnnotations[ann.Name] </span><span class="cov8" title="1">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("duplicate annotation @%s in endpoint %s %q", ann.Name, decl.Method, decl.Path)))
                }</span>
                <span class="cov8" title="1">seenAnnotations[ann.Name] = true

                // Validate annotation name format
                if !isValidIdentifier(ann.Name) </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("invalid annotation name @%s", ann.Name)))
                }</span>

                // Check if annotation is known (soft validation - unknown annotations are warnings)
                <span class="cov8" title="1">if !validAnnotations[ann.Name] </span>{<span class="cov0" title="0">
                        // This could be a custom annotation, so just a soft warning
                }</span>

                // Validate annotation-specific requirements
                <span class="cov8" title="1">v.validateAnnotationValue(ann, decl)</span>
        }
}

// validateAnnotationValue validates annotation-specific value requirements.
func (v *EndpointValidator) validateAnnotationValue(ann *ast.Annotation, decl *ast.EndpointDecl) <span class="cov8" title="1">{
        switch ann.Name </span>{
        case "auth":<span class="cov8" title="1">
                // @auth requires a value (the auth provider or role)
                if ann.Value == "" </span><span class="cov8" title="1">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("@auth annotation requires a value in endpoint %s %q", decl.Method, decl.Path)))
                }</span>
        case "rate_limit":<span class="cov8" title="1">
                // @rate_limit should have a numeric value
                if ann.Value != "" </span><span class="cov8" title="1">{
                        if _, err := strconv.Atoi(ann.Value); err != nil </span><span class="cov8" title="1">{
                                v.errors.Add(newSemanticError(decl.Pos(),
                                        fmt.Sprintf("@rate_limit annotation value must be numeric in endpoint %s %q", decl.Method, decl.Path)))
                        }</span>
                }
        case "version":<span class="cov8" title="1">
                // @version should follow semver pattern
                if ann.Value != "" &amp;&amp; !isValidVersion(ann.Value) </span><span class="cov8" title="1">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("@version annotation value %q should follow semver format (e.g., 'v1', 'v2.0')", ann.Value)))
                }</span>
        }
}

// isValidVersion checks if a string is a valid version format.
var versionPattern = regexp.MustCompile(`^v?\d+(\.\d+)*$`)

func isValidVersion(version string) bool <span class="cov8" title="1">{
        return versionPattern.MatchString(version)
}</span>

// validateHandler validates the endpoint handler.
func (v *EndpointValidator) validateHandler(decl *ast.EndpointDecl) <span class="cov8" title="1">{
        if decl.Handler == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">handler := decl.Handler

        // Validate request type
        if handler.Request != nil </span><span class="cov8" title="1">{
                v.validateRequestType(handler.Request, decl)
        }</span>

        // Validate response type
        <span class="cov8" title="1">if handler.Response != nil </span><span class="cov8" title="1">{
                v.validateResponseType(handler.Response, decl)
        }</span>

        // Validate logic block
        <span class="cov8" title="1">if handler.Logic != nil </span><span class="cov8" title="1">{
                v.validateHandlerLogic(handler.Logic, decl)
        }</span>

        // Validate consistency between request source and HTTP method
        <span class="cov8" title="1">if handler.Request != nil </span><span class="cov8" title="1">{
                v.validateRequestSourceMethodConsistency(handler.Request, decl)
        }</span>
}

// validateRequestType validates the request type specification.
func (v *EndpointValidator) validateRequestType(req *ast.RequestType, decl *ast.EndpointDecl) <span class="cov8" title="1">{
        // Validate type name format
        if !isValidTypeName(req.TypeName) </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(decl.Pos(),
                        fmt.Sprintf("invalid request type name %q in endpoint %s %q", req.TypeName, decl.Method, decl.Path)))
        }</span>

        // Check if type is registered (if strict validation is enabled)
        <span class="cov8" title="1">if len(v.types) &gt; 0 &amp;&amp; !v.types[req.TypeName] </span><span class="cov8" title="1">{
                v.errors.Add(newSemanticError(decl.Pos(),
                        fmt.Sprintf("unknown request type %q in endpoint %s %q", req.TypeName, decl.Method, decl.Path)))
        }</span>

        // Validate request source
        <span class="cov8" title="1">validSources := map[ast.RequestSource]bool{
                ast.RequestSourceBody:   true,
                ast.RequestSourceQuery:  true,
                ast.RequestSourcePath:   true,
                ast.RequestSourceHeader: true,
        }
        if !validSources[req.Source] </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(decl.Pos(),
                        fmt.Sprintf("invalid request source %q; valid sources: body, query, path, header", req.Source)))
        }</span>
}

// validateResponseType validates the response type specification.
func (v *EndpointValidator) validateResponseType(resp *ast.ResponseType, decl *ast.EndpointDecl) <span class="cov8" title="1">{
        // Validate type name format
        if !isValidTypeName(resp.TypeName) </span><span class="cov8" title="1">{
                v.errors.Add(newSemanticError(decl.Pos(),
                        fmt.Sprintf("invalid response type name %q in endpoint %s %q", resp.TypeName, decl.Method, decl.Path)))
        }</span>

        // Check if type is registered (if strict validation is enabled)
        <span class="cov8" title="1">if len(v.types) &gt; 0 &amp;&amp; !v.types[resp.TypeName] </span><span class="cov8" title="1">{
                v.errors.Add(newSemanticError(decl.Pos(),
                        fmt.Sprintf("unknown response type %q in endpoint %s %q", resp.TypeName, decl.Method, decl.Path)))
        }</span>

        // Validate status code
        <span class="cov8" title="1">if resp.StatusCode &lt; 100 || resp.StatusCode &gt; 599 </span><span class="cov8" title="1">{
                v.errors.Add(newSemanticError(decl.Pos(),
                        fmt.Sprintf("invalid HTTP status code %d; must be between 100 and 599", resp.StatusCode)))
        }</span>

        // Validate status code appropriateness
        <span class="cov8" title="1">v.validateStatusCodeForMethod(resp.StatusCode, decl)</span>
}

// validateStatusCodeForMethod validates that the status code is appropriate for the HTTP method.
func (v *EndpointValidator) validateStatusCodeForMethod(status int, decl *ast.EndpointDecl) <span class="cov8" title="1">{
        // Common patterns - not errors, but unusual
        switch decl.Method </span>{
        case ast.HTTPMethodPOST:<span class="cov8" title="1">
                // POST typically returns 201 Created, but 200 is also valid
                if status == 204 </span>{<span class="cov0" title="0">
                        // 204 No Content is unusual for POST but valid
                }</span>
        case ast.HTTPMethodDELETE:<span class="cov8" title="1">
                // DELETE typically returns 204 No Content or 200 OK
                if status == 201 </span><span class="cov8" title="1">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("DELETE endpoint %q returns 201 Created which is unusual", decl.Path)))
                }</span>
        }
}

// validateHandlerLogic validates the handler logic block.
func (v *EndpointValidator) validateHandlerLogic(logic *ast.HandlerLogic, decl *ast.EndpointDecl) <span class="cov8" title="1">{
        if logic == nil || len(logic.Steps) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">targets := make(map[string]bool)

        for _, step := range logic.Steps </span><span class="cov8" title="1">{
                v.validateLogicStep(step, decl, targets)
        }</span>
}

// validateLogicStep validates a single logic step.
func (v *EndpointValidator) validateLogicStep(step *ast.LogicStep, decl *ast.EndpointDecl, targets map[string]bool) <span class="cov8" title="1">{
        // Validate action name
        if step.Action == "" </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(decl.Pos(),
                        fmt.Sprintf("logic step in endpoint %s %q has empty action", decl.Method, decl.Path)))
                return
        }</span>

        <span class="cov8" title="1">if !isValidIdentifier(step.Action) </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(decl.Pos(),
                        fmt.Sprintf("invalid action name %q in endpoint %s %q", step.Action, decl.Method, decl.Path)))
        }</span>

        // Check if action is registered (if strict validation is enabled)
        <span class="cov8" title="1">if len(v.actions) &gt; 0 &amp;&amp; !v.actions[step.Action] </span><span class="cov8" title="1">{
                v.errors.Add(newSemanticError(decl.Pos(),
                        fmt.Sprintf("unknown action %q in endpoint %s %q", step.Action, decl.Method, decl.Path)))
        }</span>

        // Validate target variable
        <span class="cov8" title="1">if step.Target != "" </span><span class="cov8" title="1">{
                if !isValidIdentifier(step.Target) </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("invalid target variable name %q in endpoint %s %q", step.Target, decl.Method, decl.Path)))
                }</span>
                // Track target for potential duplicate detection
                <span class="cov8" title="1">if targets[step.Target] </span>{<span class="cov0" title="0">
                        // Reassignment is valid, but might be a mistake
                }</span>
                <span class="cov8" title="1">targets[step.Target] = true</span>
        }

        // Validate arguments
        <span class="cov8" title="1">for _, arg := range step.Args </span><span class="cov8" title="1">{
                // Arguments can be identifiers or string literals
                // String literals start with quote - skip validation for those
                if !strings.HasPrefix(arg, "\"") &amp;&amp; !isValidIdentifier(arg) &amp;&amp; arg != "request" &amp;&amp; arg != "response" </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("invalid argument %q in logic step %q", arg, step.Action)))
                }</span>
        }

        // Validate options
        <span class="cov8" title="1">for _, opt := range step.Options </span><span class="cov0" title="0">{
                if !isValidIdentifier(opt.Key) </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("invalid option key %q in logic step %q", opt.Key, step.Action)))
                }</span>
        }
}

// validateRequestSourceMethodConsistency validates that request source makes sense for the HTTP method.
func (v *EndpointValidator) validateRequestSourceMethodConsistency(req *ast.RequestType, decl *ast.EndpointDecl) <span class="cov8" title="1">{
        switch decl.Method </span>{
        case ast.HTTPMethodGET, ast.HTTPMethodDELETE:<span class="cov8" title="1">
                // GET and DELETE should not have body
                if req.Source == ast.RequestSourceBody </span><span class="cov8" title="1">{
                        v.errors.Add(newSemanticError(decl.Pos(),
                                fmt.Sprintf("%s endpoint %q has request from body; GET/DELETE requests should not have a body", decl.Method, decl.Path)))
                }</span>
        }
}

// isValidTypeName checks if a string is a valid type name (PascalCase).
var typeNamePattern = regexp.MustCompile(`^[A-Z][a-zA-Z0-9]*$`)

func isValidTypeName(name string) bool <span class="cov8" title="1">{
        return typeNamePattern.MatchString(name)
}</span>

</pre>
		
		<pre class="file" id="file1" style="display: none">// Package validator provides semantic validation for CodeAI AST.
package validator

import (
        "fmt"
        "strings"

        "github.com/bargom/codeai/internal/ast"
)

// ErrorType categorizes validation errors for structured handling.
type ErrorType int

const (
        // ErrorScope indicates a scope-related error (undefined/duplicate variables).
        ErrorScope ErrorType = iota
        // ErrorType indicates a type-related error.
        ErrorTypeCheck
        // ErrorFunction indicates a function-related error (wrong args, undefined).
        ErrorFunction
        // ErrorSemantic indicates a general semantic error.
        ErrorSemantic
)

// errorTypeNames maps ErrorType to human-readable names.
var errorTypeNames = map[ErrorType]string{
        ErrorScope:     "ScopeError",
        ErrorTypeCheck: "TypeError",
        ErrorFunction:  "FunctionError",
        ErrorSemantic:  "SemanticError",
}

// String returns the string representation of ErrorType.
func (et ErrorType) String() string <span class="cov8" title="1">{
        if name, ok := errorTypeNames[et]; ok </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("UnknownError(%d)", et)</span>
}

// ValidationError represents a single semantic validation error.
type ValidationError struct {
        Position ast.Position
        Message  string
        Type     ErrorType
}

// Error implements the error interface.
func (e *ValidationError) Error() string <span class="cov8" title="1">{
        if e.Position.IsValid() </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s: %s: %s", e.Position.String(), e.Type.String(), e.Message)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s: %s", e.Type.String(), e.Message)</span>
}

// ValidationErrors aggregates multiple validation errors.
type ValidationErrors struct {
        Errors []*ValidationError
}

// Error implements the error interface, formatting all errors.
func (ve *ValidationErrors) Error() string <span class="cov8" title="1">{
        if len(ve.Errors) == 0 </span><span class="cov8" title="1">{
                return "no validation errors"
        }</span>

        <span class="cov8" title="1">if len(ve.Errors) == 1 </span><span class="cov8" title="1">{
                return ve.Errors[0].Error()
        }</span>

        <span class="cov8" title="1">var sb strings.Builder
        sb.WriteString(fmt.Sprintf("%d validation errors:\n", len(ve.Errors)))
        for i, err := range ve.Errors </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("  %d. %s\n", i+1, err.Error()))
        }</span>
        <span class="cov8" title="1">return sb.String()</span>
}

// Add appends a validation error to the collection.
func (ve *ValidationErrors) Add(err *ValidationError) <span class="cov8" title="1">{
        ve.Errors = append(ve.Errors, err)
}</span>

// HasErrors returns true if there are any validation errors.
func (ve *ValidationErrors) HasErrors() bool <span class="cov8" title="1">{
        return len(ve.Errors) &gt; 0
}</span>

// Unwrap returns the underlying errors for errors.Is/As compatibility.
func (ve *ValidationErrors) Unwrap() []error <span class="cov8" title="1">{
        errs := make([]error, len(ve.Errors))
        for i, e := range ve.Errors </span><span class="cov8" title="1">{
                errs[i] = e
        }</span>
        <span class="cov8" title="1">return errs</span>
}

// Helper functions to create specific error types

// newScopeError creates a scope-related validation error.
func newScopeError(pos ast.Position, message string) *ValidationError <span class="cov8" title="1">{
        return &amp;ValidationError{
                Position: pos,
                Message:  message,
                Type:     ErrorScope,
        }
}</span>

// newTypeError creates a type-related validation error.
func newTypeError(pos ast.Position, message string) *ValidationError <span class="cov8" title="1">{
        return &amp;ValidationError{
                Position: pos,
                Message:  message,
                Type:     ErrorTypeCheck,
        }
}</span>

// newFunctionError creates a function-related validation error.
func newFunctionError(pos ast.Position, message string) *ValidationError <span class="cov8" title="1">{
        return &amp;ValidationError{
                Position: pos,
                Message:  message,
                Type:     ErrorFunction,
        }
}</span>

// newSemanticError creates a general semantic validation error.
func newSemanticError(pos ast.Position, message string) *ValidationError <span class="cov8" title="1">{
        return &amp;ValidationError{
                Position: pos,
                Message:  message,
                Type:     ErrorSemantic,
        }
}</span>

// Specific error constructors for common validation failures

func errUndefinedVariable(pos ast.Position, name string) *ValidationError <span class="cov8" title="1">{
        return newScopeError(pos, fmt.Sprintf("undefined variable '%s'", name))
}</span>

func errDuplicateDeclaration(pos ast.Position, name string) *ValidationError <span class="cov8" title="1">{
        return newScopeError(pos, fmt.Sprintf("duplicate declaration '%s'", name))
}</span>

func errDuplicateParameter(pos ast.Position, name string) *ValidationError <span class="cov8" title="1">{
        return newScopeError(pos, fmt.Sprintf("duplicate parameter '%s'", name))
}</span>

func errUndefinedFunction(pos ast.Position, name string) *ValidationError <span class="cov8" title="1">{
        return newFunctionError(pos, fmt.Sprintf("undefined function '%s'", name))
}</span>

func errWrongArgCount(pos ast.Position, name string, expected, got int) *ValidationError <span class="cov8" title="1">{
        return newFunctionError(pos, fmt.Sprintf("wrong number of arguments for '%s': expected %d, got %d", name, expected, got))
}</span>

func errNotAFunction(pos ast.Position, name string) *ValidationError <span class="cov8" title="1">{
        return newFunctionError(pos, fmt.Sprintf("'%s' is not a function", name))
}</span>

func errCannotIterate(pos ast.Position, typeName string) *ValidationError <span class="cov8" title="1">{
        return newTypeError(pos, fmt.Sprintf("cannot iterate over non-array type '%s'", typeName))
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package validator provides semantic validation for event, integration, and webhook AST nodes.
package validator

import (
        "net/url"
        "regexp"
        "strings"

        "github.com/bargom/codeai/internal/ast"
)

// EventValidation extends the Validator with event-related state.
type EventValidation struct {
        events       map[string]*ast.EventDecl
        handlers     []*ast.EventHandlerDecl
        integrations map[string]*ast.IntegrationDecl
        webhooks     map[string]*ast.WebhookDecl
        workflows    map[string]*ast.WorkflowDecl
}

// initEventValidation initializes event validation state.
func (v *Validator) initEventValidation() <span class="cov0" title="0">{
        if v.eventValidation == nil </span><span class="cov0" title="0">{
                v.eventValidation = &amp;EventValidation{
                        events:       make(map[string]*ast.EventDecl),
                        handlers:     make([]*ast.EventHandlerDecl, 0),
                        integrations: make(map[string]*ast.IntegrationDecl),
                        webhooks:     make(map[string]*ast.WebhookDecl),
                        workflows:    make(map[string]*ast.WorkflowDecl),
                }
        }</span>
}

// validateEventDecl validates an event declaration.
func (v *Validator) validateEventDecl(event *ast.EventDecl) <span class="cov0" title="0">{
        v.initEventValidation()

        // Validate event name format (resource.action pattern)
        if !isValidEventNameFormat(event.Name) </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(event.Pos(),
                        "event name '"+event.Name+"' should follow resource.action or resource_action pattern"))
        }</span>

        // Check for duplicate event
        <span class="cov0" title="0">if existing, exists := v.eventValidation.events[event.Name]; exists </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(event.Pos(),
                        "duplicate event '"+event.Name+"'; first declared at "+existing.Pos().String()))
                return
        }</span>
        <span class="cov0" title="0">v.eventValidation.events[event.Name] = event

        // Validate schema if present
        if event.Schema != nil </span><span class="cov0" title="0">{
                v.validateEventSchema(event.Schema, event.Name)
        }</span>
}

// validateEventSchema validates an event schema.
func (v *Validator) validateEventSchema(schema *ast.EventSchema, eventName string) <span class="cov0" title="0">{
        fieldNames := make(map[string]bool)
        validTypes := map[string]bool{
                "string": true, "int": true, "integer": true, "decimal": true, "float": true,
                "bool": true, "boolean": true, "timestamp": true, "datetime": true,
                "array": true, "object": true, "uuid": true,
        }

        for _, field := range schema.Fields </span><span class="cov0" title="0">{
                // Check for duplicate field names
                if fieldNames[field.Name] </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(field.Pos(),
                                "duplicate field '"+field.Name+"' in event '"+eventName+"' schema"))
                }</span>
                <span class="cov0" title="0">fieldNames[field.Name] = true

                // Validate field type
                if !validTypes[strings.ToLower(field.FieldType)] </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(field.Pos(),
                                "unknown field type '"+field.FieldType+"' in event '"+eventName+"' schema; "+
                                        "valid types: string, int, decimal, bool, timestamp, array, object, uuid"))
                }</span>
        }
}

// validateEventHandler validates an event handler declaration.
func (v *Validator) validateEventHandler(handler *ast.EventHandlerDecl) <span class="cov0" title="0">{
        v.initEventValidation()
        v.eventValidation.handlers = append(v.eventValidation.handlers, handler)

        // Validate action type
        validActions := map[string]bool{
                "workflow": true, "integration": true, "emit": true, "webhook": true,
        }
        if !validActions[handler.ActionType] </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(handler.Pos(),
                        "invalid action type '"+handler.ActionType+"'; valid types: workflow, integration, emit, webhook"))
        }</span>

        // Note: We defer reference validation to a second pass after all declarations are collected
}

// validateIntegrationDecl validates an integration declaration.
func (v *Validator) validateIntegrationDecl(intg *ast.IntegrationDecl) <span class="cov0" title="0">{
        v.initEventValidation()

        // Check for duplicate integration
        if existing, exists := v.eventValidation.integrations[intg.Name]; exists </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(intg.Pos(),
                        "duplicate integration '"+intg.Name+"'; first declared at "+existing.Pos().String()))
                return
        }</span>
        <span class="cov0" title="0">v.eventValidation.integrations[intg.Name] = intg

        // Validate integration type
        validTypes := map[ast.IntegrationType]bool{
                ast.IntegrationTypeREST:    true,
                ast.IntegrationTypeGraphQL: true,
                ast.IntegrationTypeGRPC:    true,
                ast.IntegrationTypeWebhook: true,
        }
        if !validTypes[intg.IntgType] </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(intg.Pos(),
                        "unknown integration type '"+string(intg.IntgType)+"'; valid types: rest, graphql, grpc, webhook"))
        }</span>

        // Validate base URL (must be valid HTTPS in production)
        <span class="cov0" title="0">if intg.BaseURL == "" </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(intg.Pos(),
                        "integration '"+intg.Name+"' requires a base_url"))
        }</span> else<span class="cov0" title="0"> {
                parsedURL, err := url.Parse(intg.BaseURL)
                if err != nil </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(intg.Pos(),
                                "invalid base_url in integration '"+intg.Name+"': "+err.Error()))
                }</span> else<span class="cov0" title="0"> if parsedURL.Scheme != "https" &amp;&amp; parsedURL.Scheme != "http" </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(intg.Pos(),
                                "base_url in integration '"+intg.Name+"' should use https:// or http:// scheme"))
                }</span>
        }

        // Validate auth configuration
        <span class="cov0" title="0">if intg.Auth != nil </span><span class="cov0" title="0">{
                v.validateIntegrationAuth(intg.Auth, intg.Name)
        }</span>

        // Validate circuit breaker configuration
        <span class="cov0" title="0">if intg.CircuitBreaker != nil </span><span class="cov0" title="0">{
                v.validateCircuitBreaker(intg.CircuitBreaker, intg.Name)
        }</span>
}

// validateIntegrationAuth validates authentication configuration.
func (v *Validator) validateIntegrationAuth(auth *ast.IntegrationAuthDecl, integrationName string) <span class="cov0" title="0">{
        switch auth.AuthType </span>{
        case ast.IntegrationAuthBearer:<span class="cov0" title="0">
                // Bearer auth requires a token
                if _, hasToken := auth.Config["token"]; !hasToken </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(auth.Pos(),
                                "bearer auth in integration '"+integrationName+"' requires 'token' config"))
                }</span>
        case ast.IntegrationAuthAPIKey:<span class="cov0" title="0">
                // API key auth requires header and value
                if _, hasHeader := auth.Config["header"]; !hasHeader </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(auth.Pos(),
                                "apikey auth in integration '"+integrationName+"' requires 'header' config"))
                }</span>
                <span class="cov0" title="0">if _, hasValue := auth.Config["value"]; !hasValue </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(auth.Pos(),
                                "apikey auth in integration '"+integrationName+"' requires 'value' config"))
                }</span>
        case ast.IntegrationAuthBasic, ast.IntegrationAuthOAuth2:<span class="cov0" title="0"></span>
                // Additional validation for other auth types can be added here
        default:<span class="cov0" title="0">
                v.errors.Add(newSemanticError(auth.Pos(),
                        "unknown auth type in integration '"+integrationName+"'"))</span>
        }
}

// validateCircuitBreaker validates circuit breaker configuration.
func (v *Validator) validateCircuitBreaker(cb *ast.CircuitBreakerConfig, integrationName string) <span class="cov0" title="0">{
        if cb.FailureThreshold &lt;= 0 </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(cb.Pos(),
                        "circuit_breaker threshold must be positive in integration '"+integrationName+"'"))
        }</span>

        <span class="cov0" title="0">if cb.MaxConcurrent &lt;= 0 </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(cb.Pos(),
                        "circuit_breaker max_concurrent must be positive in integration '"+integrationName+"'"))
        }</span>

        // Validate timeout format
        <span class="cov0" title="0">if cb.Timeout == "" </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(cb.Pos(),
                        "circuit_breaker timeout is required in integration '"+integrationName+"'"))
        }</span>
}

// validateWebhookDecl validates a webhook declaration.
func (v *Validator) validateWebhookDecl(webhook *ast.WebhookDecl) <span class="cov0" title="0">{
        v.initEventValidation()

        // Check for duplicate webhook
        if existing, exists := v.eventValidation.webhooks[webhook.Name]; exists </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(webhook.Pos(),
                        "duplicate webhook '"+webhook.Name+"'; first declared at "+existing.Pos().String()))
                return
        }</span>
        <span class="cov0" title="0">v.eventValidation.webhooks[webhook.Name] = webhook

        // Validate URL (must be valid HTTPS)
        if webhook.URL == "" </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(webhook.Pos(),
                        "webhook '"+webhook.Name+"' requires a url"))
        }</span> else<span class="cov0" title="0"> {
                parsedURL, err := url.Parse(webhook.URL)
                if err != nil </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(webhook.Pos(),
                                "invalid url in webhook '"+webhook.Name+"': "+err.Error()))
                }</span> else<span class="cov0" title="0"> if parsedURL.Scheme != "https" &amp;&amp; parsedURL.Scheme != "http" </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(webhook.Pos(),
                                "url in webhook '"+webhook.Name+"' should use https:// or http:// scheme"))
                }</span>
        }

        // Validate event name
        <span class="cov0" title="0">if webhook.Event == "" </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(webhook.Pos(),
                        "webhook '"+webhook.Name+"' requires an event name"))
        }</span>

        // Validate retry configuration
        <span class="cov0" title="0">if webhook.Retry != nil </span><span class="cov0" title="0">{
                if webhook.Retry.MaxAttempts &lt;= 0 </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(webhook.Pos(),
                                "retry max_attempts must be positive in webhook '"+webhook.Name+"'"))
                }</span>
                <span class="cov0" title="0">if webhook.Retry.BackoffMultiplier &lt; 1.0 </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(webhook.Pos(),
                                "retry backoff must be &gt;= 1.0 in webhook '"+webhook.Name+"'"))
                }</span>
        }
}

// validateEventReferences validates that all event handler references are valid.
// This should be called after all declarations have been collected.
func (v *Validator) validateEventReferences() <span class="cov8" title="1">{
        if v.eventValidation == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">for _, handler := range v.eventValidation.handlers </span><span class="cov0" title="0">{
                switch handler.ActionType </span>{
                case "workflow":<span class="cov0" title="0">
                        // Check if workflow exists
                        if _, exists := v.eventValidation.workflows[handler.Target]; !exists </span>{<span class="cov0" title="0">
                                // Note: workflows might be defined elsewhere, so this is a warning
                                // v.errors.Add(newSemanticError(handler.Pos(),
                                //         "event handler references unknown workflow '"+handler.Target+"'"))
                        }</span>
                case "integration":<span class="cov0" title="0">
                        // Check if integration exists
                        // Integration target might be "name.method", so extract just the name
                        integrationName := handler.Target
                        if idx := strings.Index(handler.Target, "."); idx &gt; 0 </span><span class="cov0" title="0">{
                                integrationName = handler.Target[:idx]
                        }</span>
                        <span class="cov0" title="0">if _, exists := v.eventValidation.integrations[integrationName]; !exists </span>{<span class="cov0" title="0">
                                // Note: This is intentionally not an error as integrations might be defined elsewhere
                        }</span>
                case "webhook":<span class="cov0" title="0">
                        // Check if webhook exists
                        if _, exists := v.eventValidation.webhooks[handler.Target]; !exists </span>{<span class="cov0" title="0">
                                // Note: This is intentionally not an error as webhooks might be defined elsewhere
                        }</span>
                case "emit":<span class="cov0" title="0"></span>
                        // Emit targets another event - validation is lenient here
                }
        }

        // Validate that webhooks reference valid events (warning only)
        <span class="cov0" title="0">for _, webhook := range v.eventValidation.webhooks </span><span class="cov0" title="0">{
                if _, exists := v.eventValidation.events[webhook.Event]; !exists </span>{<span class="cov0" title="0">
                        // Event might be defined elsewhere or be a system event
                }</span>
        }
}

// isValidEventNameFormat validates that an event name follows the expected pattern.
// Valid formats: resource.action (e.g., "user.created") or resource_action (e.g., "user_created")
func isValidEventNameFormat(name string) bool <span class="cov0" title="0">{
        // Allow formats like "user.created", "user_created", "order.completed"
        pattern := regexp.MustCompile(`^[a-zA-Z][a-zA-Z0-9_]*(\.[a-zA-Z][a-zA-Z0-9_]*)?$`)
        return pattern.MatchString(name)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package validator

import "fmt"

// SymbolKind distinguishes between different kinds of symbols.
type SymbolKind int

const (
        // SymbolVariable represents a variable declaration.
        SymbolVariable SymbolKind = iota
        // SymbolFunction represents a function declaration.
        SymbolFunction
        // SymbolParameter represents a function parameter.
        SymbolParameter
)

// symbolKindNames maps SymbolKind to string representations.
var symbolKindNames = map[SymbolKind]string{
        SymbolVariable:  "variable",
        SymbolFunction:  "function",
        SymbolParameter: "parameter",
}

// String returns the string representation of SymbolKind.
func (sk SymbolKind) String() string <span class="cov8" title="1">{
        if name, ok := symbolKindNames[sk]; ok </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("Unknown(%d)", sk)</span>
}

// Symbol represents a declared identifier in the program.
type Symbol struct {
        Name       string
        Kind       SymbolKind
        Type       Type       // Inferred type
        ParamCount int        // For functions: number of parameters
}

// scope represents a single lexical scope with its symbol mappings.
type scope struct {
        symbols map[string]*Symbol
        parent  *scope
}

// newScope creates a new scope with optional parent.
func newScope(parent *scope) *scope <span class="cov8" title="1">{
        return &amp;scope{
                symbols: make(map[string]*Symbol),
                parent:  parent,
        }
}</span>

// SymbolTable manages symbol declarations across nested scopes.
type SymbolTable struct {
        current *scope
        global  *scope // Reference to global scope for builtins
}

// NewSymbolTable creates a new symbol table with global scope initialized.
func NewSymbolTable() *SymbolTable <span class="cov8" title="1">{
        global := newScope(nil)
        st := &amp;SymbolTable{
                current: global,
                global:  global,
        }
        // Register builtin functions
        st.registerBuiltins()
        return st
}</span>

// registerBuiltins adds built-in functions to the global scope.
func (st *SymbolTable) registerBuiltins() <span class="cov8" title="1">{
        // print(value) - prints a value
        st.global.symbols["print"] = &amp;Symbol{
                Name:       "print",
                Kind:       SymbolFunction,
                ParamCount: 1,
        }

        // len(value) - returns length of array or string
        st.global.symbols["len"] = &amp;Symbol{
                Name:       "len",
                Kind:       SymbolFunction,
                ParamCount: 1,
        }
}</span>

// EnterScope creates and enters a new nested scope.
func (st *SymbolTable) EnterScope() <span class="cov8" title="1">{
        st.current = newScope(st.current)
}</span>

// ExitScope exits the current scope and returns to the parent.
func (st *SymbolTable) ExitScope() <span class="cov8" title="1">{
        if st.current.parent != nil </span><span class="cov8" title="1">{
                st.current = st.current.parent
        }</span>
}

// Declare adds a new symbol to the current scope.
// Returns an error if the symbol is already declared in the current scope.
func (st *SymbolTable) Declare(name string, kind SymbolKind) error <span class="cov8" title="1">{
        if _, exists := st.current.symbols[name]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("duplicate declaration '%s'", name)
        }</span>
        <span class="cov8" title="1">st.current.symbols[name] = &amp;Symbol{
                Name: name,
                Kind: kind,
                Type: TypeUnknown,
        }
        return nil</span>
}

// DeclareWithType adds a new symbol with a known type.
func (st *SymbolTable) DeclareWithType(name string, kind SymbolKind, typ Type) error <span class="cov8" title="1">{
        if _, exists := st.current.symbols[name]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("duplicate declaration '%s'", name)
        }</span>
        <span class="cov8" title="1">st.current.symbols[name] = &amp;Symbol{
                Name: name,
                Kind: kind,
                Type: typ,
        }
        return nil</span>
}

// DeclareFunction adds a function symbol with parameter count.
func (st *SymbolTable) DeclareFunction(name string, paramCount int) error <span class="cov8" title="1">{
        if _, exists := st.current.symbols[name]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("duplicate declaration '%s'", name)
        }</span>
        <span class="cov8" title="1">st.current.symbols[name] = &amp;Symbol{
                Name:       name,
                Kind:       SymbolFunction,
                ParamCount: paramCount,
                Type:       TypeFunction,
        }
        return nil</span>
}

// Lookup searches for a symbol starting from the current scope up to global.
// Returns the symbol and true if found, nil and false otherwise.
func (st *SymbolTable) Lookup(name string) (*Symbol, bool) <span class="cov8" title="1">{
        for scope := st.current; scope != nil; scope = scope.parent </span><span class="cov8" title="1">{
                if sym, exists := scope.symbols[name]; exists </span><span class="cov8" title="1">{
                        return sym, true
                }</span>
        }
        <span class="cov8" title="1">return nil, false</span>
}

// LookupLocal searches for a symbol only in the current scope.
// Used for checking duplicate declarations in the same scope.
func (st *SymbolTable) LookupLocal(name string) (*Symbol, bool) <span class="cov8" title="1">{
        sym, exists := st.current.symbols[name]
        return sym, exists
}</span>

// UpdateType updates the type of an existing symbol.
func (st *SymbolTable) UpdateType(name string, typ Type) <span class="cov8" title="1">{
        if sym, ok := st.Lookup(name); ok </span><span class="cov8" title="1">{
                sym.Type = typ
        }</span>
}

// CurrentScopeDepth returns the nesting depth of the current scope.
// Useful for debugging scope issues.
func (st *SymbolTable) CurrentScopeDepth() int <span class="cov8" title="1">{
        depth := 0
        for scope := st.current; scope != nil; scope = scope.parent </span><span class="cov8" title="1">{
                depth++
        }</span>
        <span class="cov8" title="1">return depth</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package validator

import (
        "github.com/bargom/codeai/internal/ast"
)

// Type represents the type of a value in the CodeAI language.
type Type int

const (
        // TypeUnknown represents an undetermined type.
        TypeUnknown Type = iota
        // TypeString represents string values.
        TypeString
        // TypeNumber represents numeric values.
        TypeNumber
        // TypeBool represents boolean values.
        TypeBool
        // TypeArray represents array values.
        TypeArray
        // TypeFunction represents function values.
        TypeFunction
        // TypeVoid represents no value (for statements).
        TypeVoid
)

// typeNames maps Type to string representations.
var typeNames = map[Type]string{
        TypeUnknown:  "unknown",
        TypeString:   "string",
        TypeNumber:   "number",
        TypeBool:     "bool",
        TypeArray:    "array",
        TypeFunction: "function",
        TypeVoid:     "void",
}

// String returns the string representation of Type.
func (t Type) String() string <span class="cov8" title="1">{
        if name, ok := typeNames[t]; ok </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">return "unknown"</span>
}

// TypeChecker performs type inference and checking on AST nodes.
type TypeChecker struct {
        symbols *SymbolTable
}

// NewTypeChecker creates a new type checker with the given symbol table.
func NewTypeChecker(symbols *SymbolTable) *TypeChecker <span class="cov8" title="1">{
        return &amp;TypeChecker{
                symbols: symbols,
        }
}</span>

// InferType determines the type of an expression.
func (tc *TypeChecker) InferType(expr ast.Expression) Type <span class="cov8" title="1">{
        if expr == nil </span><span class="cov8" title="1">{
                return TypeUnknown
        }</span>

        <span class="cov8" title="1">switch e := expr.(type) </span>{
        case *ast.StringLiteral:<span class="cov8" title="1">
                return TypeString</span>

        case *ast.NumberLiteral:<span class="cov8" title="1">
                return TypeNumber</span>

        case *ast.BoolLiteral:<span class="cov8" title="1">
                return TypeBool</span>

        case *ast.ArrayLiteral:<span class="cov8" title="1">
                return TypeArray</span>

        case *ast.Identifier:<span class="cov8" title="1">
                if sym, ok := tc.symbols.Lookup(e.Name); ok </span><span class="cov8" title="1">{
                        return sym.Type
                }</span>
                <span class="cov8" title="1">return TypeUnknown</span>

        case *ast.FunctionCall:<span class="cov8" title="1">
                // Function calls have unknown return type for now
                // Could be extended to track return types
                return TypeUnknown</span>

        case *ast.BinaryExpr:<span class="cov8" title="1">
                return tc.inferBinaryType(e)</span>

        case *ast.UnaryExpr:<span class="cov8" title="1">
                return tc.inferUnaryType(e)</span>

        default:<span class="cov0" title="0">
                return TypeUnknown</span>
        }
}

// inferBinaryType determines the result type of a binary expression.
func (tc *TypeChecker) inferBinaryType(expr *ast.BinaryExpr) Type <span class="cov8" title="1">{
        leftType := tc.InferType(expr.Left)
        rightType := tc.InferType(expr.Right)

        switch expr.Operator </span>{
        // Comparison operators return bool
        case "==", "!=", "&lt;", "&gt;", "&lt;=", "&gt;=":<span class="cov8" title="1">
                return TypeBool</span>

        // Logical operators return bool
        case "and", "or":<span class="cov8" title="1">
                return TypeBool</span>

        // Arithmetic operators
        case "+":<span class="cov8" title="1">
                // String concatenation or numeric addition
                if leftType == TypeString || rightType == TypeString </span><span class="cov8" title="1">{
                        return TypeString
                }</span>
                <span class="cov8" title="1">return TypeNumber</span>

        case "-", "*", "/", "%":<span class="cov8" title="1">
                return TypeNumber</span>

        default:<span class="cov8" title="1">
                return TypeUnknown</span>
        }
}

// inferUnaryType determines the result type of a unary expression.
func (tc *TypeChecker) inferUnaryType(expr *ast.UnaryExpr) Type <span class="cov8" title="1">{
        switch expr.Operator </span>{
        case "not", "!":<span class="cov8" title="1">
                return TypeBool</span>
        case "-":<span class="cov8" title="1">
                return TypeNumber</span>
        default:<span class="cov8" title="1">
                return TypeUnknown</span>
        }
}

// IsIterable checks if a type can be used in a for-in loop.
func (tc *TypeChecker) IsIterable(typ Type) bool <span class="cov8" title="1">{
        // Only arrays are iterable in CodeAI
        return typ == TypeArray
}</span>

// CheckCompatible checks if two types are compatible for an operation.
func (tc *TypeChecker) CheckCompatible(left, right Type) bool <span class="cov8" title="1">{
        // Same types are always compatible
        if left == right </span><span class="cov8" title="1">{
                return true
        }</span>

        // Unknown types are compatible with anything (allows more lenient checking)
        <span class="cov8" title="1">if left == TypeUnknown || right == TypeUnknown </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package validator provides semantic validation for CodeAI AST.
package validator

import (
        "github.com/bargom/codeai/internal/ast"
)

// Validator performs semantic analysis on CodeAI AST.
type Validator struct {
        symbols        *SymbolTable
        typeChecker    *TypeChecker
        errors         *ValidationErrors
        types          map[string]Type // Track variable types for testing
        configDecl     *ast.ConfigDecl // Track config declaration for validation
        databaseBlocks []*ast.DatabaseBlock // Track database blocks for validation
        // Auth, Role, and Middleware tracking
        authProviders map[string]*ast.AuthDecl
        roles         map[string]*ast.RoleDecl
        middlewares   map[string]*ast.MiddlewareDecl
        // Event, Integration, and Webhook tracking
        eventValidation *EventValidation
}

// New creates a new Validator instance.
func New() *Validator <span class="cov8" title="1">{
        symbols := NewSymbolTable()
        return &amp;Validator{
                symbols:       symbols,
                typeChecker:   NewTypeChecker(symbols),
                errors:        &amp;ValidationErrors{},
                types:         make(map[string]Type),
                authProviders: make(map[string]*ast.AuthDecl),
                roles:         make(map[string]*ast.RoleDecl),
                middlewares:   make(map[string]*ast.MiddlewareDecl),
        }
}</span>

// Validate performs semantic validation on the given AST program.
// It returns an error if any validation issues are found.
func (v *Validator) Validate(program *ast.Program) error <span class="cov8" title="1">{
        if program == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // First pass: collect function declarations (for forward references)
        // Note: CodeAI requires declaration before use, so this is optional
        // For now, we'll validate in order

        // Validate all statements
        <span class="cov8" title="1">for _, stmt := range program.Statements </span><span class="cov8" title="1">{
                v.validateStatement(stmt)
        }</span>

        // Validate that database_type in config matches declared database blocks
        <span class="cov8" title="1">v.validateDatabaseTypeConsistency()

        // Validate event handler references (second pass after all declarations collected)
        v.validateEventReferences()

        // Return aggregated errors if any
        if v.errors.HasErrors() </span><span class="cov8" title="1">{
                return v.errors
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// TypeOf returns the inferred type of a variable by name.
// Used for testing type inference.
func (v *Validator) TypeOf(name string) (Type, bool) <span class="cov8" title="1">{
        typ, ok := v.types[name]
        return typ, ok
}</span>

// validateStatement dispatches validation based on statement type.
func (v *Validator) validateStatement(stmt ast.Statement) <span class="cov8" title="1">{
        if stmt == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">switch s := stmt.(type) </span>{
        case *ast.ConfigDecl:<span class="cov8" title="1">
                v.validateConfigDecl(s)</span>
        case *ast.DatabaseBlock:<span class="cov8" title="1">
                v.validateDatabaseBlock(s)</span>
        case *ast.ModelDecl:<span class="cov0" title="0">
                v.validateModelDecl(s)</span>
        case *ast.CollectionDecl:<span class="cov0" title="0">
                v.validateCollectionDecl(s)</span>
        case *ast.VarDecl:<span class="cov8" title="1">
                v.validateVarDecl(s)</span>
        case *ast.Assignment:<span class="cov8" title="1">
                v.validateAssignment(s)</span>
        case *ast.IfStmt:<span class="cov8" title="1">
                v.validateIfStmt(s)</span>
        case *ast.ForLoop:<span class="cov8" title="1">
                v.validateForLoop(s)</span>
        case *ast.FunctionDecl:<span class="cov8" title="1">
                v.validateFunctionDecl(s)</span>
        case *ast.ExecBlock:<span class="cov8" title="1">
                v.validateExecBlock(s)</span>
        case *ast.Block:<span class="cov8" title="1">
                v.validateBlock(s)</span>
        case *ast.ReturnStmt:<span class="cov8" title="1">
                v.validateReturnStmt(s)</span>
        case *ast.AuthDecl:<span class="cov0" title="0">
                v.validateAuthDecl(s)</span>
        case *ast.RoleDecl:<span class="cov0" title="0">
                v.validateRoleDecl(s)</span>
        case *ast.MiddlewareDecl:<span class="cov0" title="0">
                v.validateMiddlewareDecl(s)</span>
        case *ast.EventDecl:<span class="cov0" title="0">
                v.validateEventDecl(s)</span>
        case *ast.EventHandlerDecl:<span class="cov0" title="0">
                v.validateEventHandler(s)</span>
        case *ast.IntegrationDecl:<span class="cov0" title="0">
                v.validateIntegrationDecl(s)</span>
        case *ast.WebhookDecl:<span class="cov0" title="0">
                v.validateWebhookDecl(s)</span>
        }
}

// validateVarDecl validates a variable declaration.
func (v *Validator) validateVarDecl(decl *ast.VarDecl) <span class="cov8" title="1">{
        // First, validate the value expression
        v.validateExpression(decl.Value)

        // Check for duplicate declaration in current scope
        if _, exists := v.symbols.LookupLocal(decl.Name); exists </span><span class="cov8" title="1">{
                v.errors.Add(errDuplicateDeclaration(decl.Pos(), decl.Name))
                return
        }</span>

        // Infer type from value
        <span class="cov8" title="1">typ := v.typeChecker.InferType(decl.Value)

        // Declare the variable with its type
        if err := v.symbols.DeclareWithType(decl.Name, SymbolVariable, typ); err != nil </span><span class="cov0" title="0">{
                v.errors.Add(errDuplicateDeclaration(decl.Pos(), decl.Name))
                return
        }</span>

        // Track type for testing
        <span class="cov8" title="1">v.types[decl.Name] = typ</span>
}

// validateAssignment validates an assignment statement.
func (v *Validator) validateAssignment(assign *ast.Assignment) <span class="cov8" title="1">{
        // First, validate the value expression
        v.validateExpression(assign.Value)

        // Check that the variable is declared
        sym, ok := v.symbols.Lookup(assign.Name)
        if !ok </span><span class="cov8" title="1">{
                v.errors.Add(errUndefinedVariable(assign.Pos(), assign.Name))
                return
        }</span>

        // Verify it's a variable, not a function
        <span class="cov8" title="1">if sym.Kind == SymbolFunction </span><span class="cov8" title="1">{
                v.errors.Add(newScopeError(assign.Pos(), "cannot assign to function '"+assign.Name+"'"))
                return
        }</span>

        // Update type if we can infer a more specific type
        <span class="cov8" title="1">newType := v.typeChecker.InferType(assign.Value)
        if newType != TypeUnknown </span><span class="cov8" title="1">{
                v.symbols.UpdateType(assign.Name, newType)
                v.types[assign.Name] = newType
        }</span>
}

// validateIfStmt validates an if statement.
func (v *Validator) validateIfStmt(ifStmt *ast.IfStmt) <span class="cov8" title="1">{
        // Validate condition expression
        v.validateExpression(ifStmt.Condition)

        // Validate then block in new scope
        v.symbols.EnterScope()
        v.validateBlock(ifStmt.Then)
        v.symbols.ExitScope()

        // Validate else block if present
        if ifStmt.Else != nil </span><span class="cov8" title="1">{
                v.symbols.EnterScope()
                v.validateBlock(ifStmt.Else)
                v.symbols.ExitScope()
        }</span>
}

// validateForLoop validates a for-in loop.
func (v *Validator) validateForLoop(forLoop *ast.ForLoop) <span class="cov8" title="1">{
        // Validate iterable expression
        v.validateExpression(forLoop.Iterable)

        // Check that iterable is actually iterable (array)
        iterableType := v.typeChecker.InferType(forLoop.Iterable)
        if iterableType != TypeUnknown &amp;&amp; !v.typeChecker.IsIterable(iterableType) </span><span class="cov8" title="1">{
                v.errors.Add(errCannotIterate(forLoop.Pos(), iterableType.String()))
        }</span>

        // Enter new scope for loop body
        <span class="cov8" title="1">v.symbols.EnterScope()

        // Declare loop variable in loop scope
        // Loop variable type is element type of array (unknown for now)
        if err := v.symbols.DeclareWithType(forLoop.Variable, SymbolVariable, TypeUnknown); err != nil </span><span class="cov0" title="0">{
                v.errors.Add(errDuplicateDeclaration(forLoop.Pos(), forLoop.Variable))
        }</span>

        // Validate body
        <span class="cov8" title="1">v.validateBlock(forLoop.Body)

        v.symbols.ExitScope()</span>
}

// validateFunctionDecl validates a function declaration.
func (v *Validator) validateFunctionDecl(funcDecl *ast.FunctionDecl) <span class="cov8" title="1">{
        // Check for duplicate declaration
        if _, exists := v.symbols.LookupLocal(funcDecl.Name); exists </span><span class="cov8" title="1">{
                v.errors.Add(errDuplicateDeclaration(funcDecl.Pos(), funcDecl.Name))
                return
        }</span>

        // Declare function
        <span class="cov8" title="1">if err := v.symbols.DeclareFunction(funcDecl.Name, len(funcDecl.Params)); err != nil </span><span class="cov0" title="0">{
                v.errors.Add(errDuplicateDeclaration(funcDecl.Pos(), funcDecl.Name))
                return
        }</span>

        // Enter new scope for function body
        <span class="cov8" title="1">v.symbols.EnterScope()

        // Check for duplicate parameter names and declare params
        paramNames := make(map[string]bool)
        for _, param := range funcDecl.Params </span><span class="cov8" title="1">{
                if paramNames[param.Name] </span><span class="cov8" title="1">{
                        v.errors.Add(errDuplicateParameter(funcDecl.Pos(), param.Name))
                }</span> else<span class="cov8" title="1"> {
                        paramNames[param.Name] = true
                        if err := v.symbols.DeclareWithType(param.Name, SymbolParameter, TypeUnknown); err != nil </span><span class="cov0" title="0">{
                                v.errors.Add(errDuplicateDeclaration(funcDecl.Pos(), param.Name))
                        }</span>
                }
        }

        // Validate function body
        <span class="cov8" title="1">v.validateBlock(funcDecl.Body)

        v.symbols.ExitScope()</span>
}

// validateExecBlock validates an exec block (shell command).
func (v *Validator) validateExecBlock(exec *ast.ExecBlock) {<span class="cov8" title="1">
        // Exec blocks don't have semantic validation
        // Could add checks for dangerous commands if needed
}</span>

// validateBlock validates a block of statements.
func (v *Validator) validateBlock(block *ast.Block) <span class="cov8" title="1">{
        if block == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for _, stmt := range block.Statements </span><span class="cov8" title="1">{
                v.validateStatement(stmt)
        }</span>
}

// validateReturnStmt validates a return statement.
func (v *Validator) validateReturnStmt(ret *ast.ReturnStmt) <span class="cov8" title="1">{
        if ret.Value != nil </span><span class="cov8" title="1">{
                v.validateExpression(ret.Value)
        }</span>
}

// validateExpression validates an expression and checks all referenced variables.
func (v *Validator) validateExpression(expr ast.Expression) <span class="cov8" title="1">{
        if expr == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">switch e := expr.(type) </span>{
        case *ast.Identifier:<span class="cov8" title="1">
                v.validateIdentifier(e)</span>

        case *ast.FunctionCall:<span class="cov8" title="1">
                v.validateFunctionCall(e)</span>

        case *ast.ArrayLiteral:<span class="cov8" title="1">
                for _, elem := range e.Elements </span><span class="cov8" title="1">{
                        v.validateExpression(elem)
                }</span>

        case *ast.BinaryExpr:<span class="cov8" title="1">
                v.validateExpression(e.Left)
                v.validateExpression(e.Right)</span>

        case *ast.UnaryExpr:<span class="cov8" title="1">
                v.validateExpression(e.Operand)</span>

        // Literals don't need validation
        case *ast.StringLiteral, *ast.NumberLiteral, *ast.BoolLiteral:<span class="cov8" title="1"></span>
                // No validation needed
        }
}

// validateIdentifier checks that an identifier is declared.
func (v *Validator) validateIdentifier(ident *ast.Identifier) <span class="cov8" title="1">{
        if _, ok := v.symbols.Lookup(ident.Name); !ok </span><span class="cov8" title="1">{
                v.errors.Add(errUndefinedVariable(ident.Pos(), ident.Name))
        }</span>
}

// validateFunctionCall validates a function call expression.
func (v *Validator) validateFunctionCall(call *ast.FunctionCall) <span class="cov8" title="1">{
        // Validate arguments first
        for _, arg := range call.Args </span><span class="cov8" title="1">{
                v.validateExpression(arg)
        }</span>

        // Look up the function
        <span class="cov8" title="1">sym, ok := v.symbols.Lookup(call.Name)
        if !ok </span><span class="cov8" title="1">{
                v.errors.Add(errUndefinedFunction(call.Pos(), call.Name))
                return
        }</span>

        // Verify it's a function
        <span class="cov8" title="1">if sym.Kind != SymbolFunction </span><span class="cov8" title="1">{
                v.errors.Add(errNotAFunction(call.Pos(), call.Name))
                return
        }</span>

        // Check argument count
        <span class="cov8" title="1">if len(call.Args) != sym.ParamCount </span><span class="cov8" title="1">{
                v.errors.Add(errWrongArgCount(call.Pos(), call.Name, sym.ParamCount, len(call.Args)))
        }</span>
}

// validateConfigDecl validates a config block declaration.
func (v *Validator) validateConfigDecl(cfg *ast.ConfigDecl) <span class="cov8" title="1">{
        // Check for duplicate config declaration
        if v.configDecl != nil </span><span class="cov8" title="1">{
                v.errors.Add(newSemanticError(cfg.Pos(), "duplicate config declaration; only one config block allowed"))
                return
        }</span>
        <span class="cov8" title="1">v.configDecl = cfg

        // Validate database_type value
        if cfg.DatabaseType != ast.DatabaseTypePostgres &amp;&amp; cfg.DatabaseType != ast.DatabaseTypeMongoDB </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(cfg.Pos(),
                        "invalid database_type: must be 'postgres' or 'mongodb'"))
        }</span>

        // If MongoDB is specified, validate required MongoDB config fields
        <span class="cov8" title="1">if cfg.DatabaseType == ast.DatabaseTypeMongoDB </span><span class="cov8" title="1">{
                if cfg.MongoDBURI == "" </span><span class="cov8" title="1">{
                        v.errors.Add(newSemanticError(cfg.Pos(),
                                "mongodb_uri is required when database_type is 'mongodb'"))
                }</span>
                <span class="cov8" title="1">if cfg.MongoDBName == "" </span><span class="cov8" title="1">{
                        v.errors.Add(newSemanticError(cfg.Pos(),
                                "mongodb_database is required when database_type is 'mongodb'"))
                }</span>
        }
}

// validateDatabaseBlock validates a database block declaration.
func (v *Validator) validateDatabaseBlock(db *ast.DatabaseBlock) <span class="cov8" title="1">{
        v.databaseBlocks = append(v.databaseBlocks, db)

        // Validate nested statements
        for _, stmt := range db.Statements </span><span class="cov0" title="0">{
                v.validateStatement(stmt)
        }</span>
}

// validateDatabaseTypeConsistency validates that database_type in config
// matches the declared database blocks.
func (v *Validator) validateDatabaseTypeConsistency() <span class="cov8" title="1">{
        if v.configDecl == nil &amp;&amp; len(v.databaseBlocks) == 0 </span><span class="cov8" title="1">{
                // No config or database blocks - nothing to validate
                return
        }</span>

        // Default database type is postgres
        <span class="cov8" title="1">configDBType := ast.DatabaseTypePostgres
        if v.configDecl != nil </span><span class="cov8" title="1">{
                configDBType = v.configDecl.DatabaseType
        }</span>

        // Check that all database blocks match the config database_type
        <span class="cov8" title="1">for _, db := range v.databaseBlocks </span><span class="cov8" title="1">{
                if db.DBType != configDBType </span><span class="cov8" title="1">{
                        var pos ast.Position
                        if v.configDecl != nil </span><span class="cov8" title="1">{
                                pos = v.configDecl.Pos()
                        }</span> else<span class="cov8" title="1"> {
                                pos = db.Pos()
                        }</span>
                        <span class="cov8" title="1">v.errors.Add(newSemanticError(pos,
                                "database block type '"+string(db.DBType)+
                                        "' does not match config database_type '"+string(configDBType)+
                                        "'; all database blocks must match the configured database type"))</span>
                }
        }

        // If config specifies mongodb, ensure at least one mongodb block exists
        <span class="cov8" title="1">if v.configDecl != nil &amp;&amp; v.configDecl.DatabaseType == ast.DatabaseTypeMongoDB </span><span class="cov8" title="1">{
                hasMongoBlock := false
                for _, db := range v.databaseBlocks </span><span class="cov8" title="1">{
                        if db.DBType == ast.DatabaseTypeMongoDB </span><span class="cov8" title="1">{
                                hasMongoBlock = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !hasMongoBlock &amp;&amp; len(v.databaseBlocks) &gt; 0 </span><span class="cov8" title="1">{
                        v.errors.Add(newSemanticError(v.configDecl.Pos(),
                                "config specifies database_type 'mongodb' but no mongodb database block found"))
                }</span>
        }
}

// =============================================================================
// PostgreSQL Model Validation
// =============================================================================

// validateModelDecl validates a PostgreSQL model declaration.
func (v *Validator) validateModelDecl(model *ast.ModelDecl) <span class="cov0" title="0">{
        // Track field names for duplicate checking
        fieldNames := make(map[string]bool)

        for _, field := range model.Fields </span><span class="cov0" title="0">{
                // Check for duplicate field names
                if fieldNames[field.Name] </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(field.Pos(),
                                "duplicate field '"+field.Name+"' in model '"+model.Name+"'"))
                }</span>
                <span class="cov0" title="0">fieldNames[field.Name] = true

                // Validate field type
                v.validateFieldType(field.FieldType, model.Name)

                // Validate modifiers
                v.validateModifiers(field.Modifiers, model.Name, field.Name)</span>
        }

        // Validate indexes
        <span class="cov0" title="0">for _, idx := range model.Indexes </span><span class="cov0" title="0">{
                for _, fieldName := range idx.Fields </span><span class="cov0" title="0">{
                        if !fieldNames[fieldName] </span><span class="cov0" title="0">{
                                v.errors.Add(newSemanticError(idx.Pos(),
                                        "index references unknown field '"+fieldName+"' in model '"+model.Name+"'"))
                        }</span>
                }
        }
}

// validateFieldType validates a PostgreSQL field type reference.
func (v *Validator) validateFieldType(typeRef *ast.TypeRef, modelName string) <span class="cov0" title="0">{
        if typeRef == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Valid PostgreSQL types
        <span class="cov0" title="0">validTypes := map[string]bool{
                "uuid": true, "string": true, "text": true, "integer": true, "int": true,
                "decimal": true, "boolean": true, "bool": true, "timestamp": true,
                "date": true, "time": true, "json": true, "jsonb": true,
                "list": true, "array": true, "ref": true, "enum": true,
        }

        if !validTypes[typeRef.Name] </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(typeRef.Pos(),
                        "unknown type '"+typeRef.Name+"' in model '"+modelName+"'; valid types: uuid, string, text, integer, decimal, boolean, timestamp, date, time, json, list, ref, enum"))
        }</span>

        // Validate type parameters - skip for ref() since params are model names, not types
        // For ref(User), the param "User" refers to a model, not a type
        <span class="cov0" title="0">if typeRef.Name != "ref" </span><span class="cov0" title="0">{
                for _, param := range typeRef.Params </span><span class="cov0" title="0">{
                        v.validateFieldType(param, modelName)
                }</span>
        }
        // TODO: For ref() types, validate that the referenced model exists
}

// validateModifiers validates field modifiers.
func (v *Validator) validateModifiers(modifiers []*ast.Modifier, modelName, fieldName string) <span class="cov0" title="0">{
        seenModifiers := make(map[string]bool)

        for _, mod := range modifiers </span><span class="cov0" title="0">{
                // Check for duplicate modifiers
                if seenModifiers[mod.Name] </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(mod.Pos(),
                                "duplicate modifier '"+mod.Name+"' on field '"+fieldName+"' in model '"+modelName+"'"))
                }</span>
                <span class="cov0" title="0">seenModifiers[mod.Name] = true

                // Validate modifier values
                if mod.Value != nil </span><span class="cov0" title="0">{
                        v.validateExpression(mod.Value)
                }</span>
        }

        // Check for conflicting modifiers
        <span class="cov0" title="0">if seenModifiers["required"] &amp;&amp; seenModifiers["optional"] </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(modifiers[0].Pos(),
                        "field '"+fieldName+"' cannot be both required and optional"))
        }</span>
}

// =============================================================================
// MongoDB Collection Validation
// =============================================================================

// validateCollectionDecl validates a MongoDB collection declaration.
func (v *Validator) validateCollectionDecl(coll *ast.CollectionDecl) <span class="cov0" title="0">{
        // Track field names for duplicate checking
        fieldNames := make(map[string]bool)

        for _, field := range coll.Fields </span><span class="cov0" title="0">{
                // Check for duplicate field names
                if fieldNames[field.Name] </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(field.Pos(),
                                "duplicate field '"+field.Name+"' in collection '"+coll.Name+"'"))
                }</span>
                <span class="cov0" title="0">fieldNames[field.Name] = true

                // Validate field type
                v.validateMongoFieldType(field.FieldType, coll.Name, field.Name, 0)

                // Validate modifiers - check for invalid modifiers in MongoDB
                v.validateMongoModifiers(field.Modifiers, coll.Name, field.Name)</span>
        }

        // Validate indexes
        <span class="cov0" title="0">for _, idx := range coll.Indexes </span><span class="cov0" title="0">{
                for _, fieldName := range idx.Fields </span><span class="cov0" title="0">{
                        if !fieldNames[fieldName] </span><span class="cov0" title="0">{
                                v.errors.Add(newSemanticError(idx.Pos(),
                                        "index references unknown field '"+fieldName+"' in collection '"+coll.Name+"'"))
                        }</span>
                }
        }
}

// validateMongoFieldType validates a MongoDB field type reference.
func (v *Validator) validateMongoFieldType(typeRef *ast.MongoTypeRef, collName, fieldName string, depth int) <span class="cov0" title="0">{
        if typeRef == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // MongoDB document nesting limit (16 levels is MongoDB's limit, we enforce 10 for safety)
        <span class="cov0" title="0">const maxNestingDepth = 10
        if depth &gt; maxNestingDepth </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(typeRef.Pos(),
                        "embedded document nesting exceeds maximum depth of "+
                                string(rune('0'+maxNestingDepth))+" in collection '"+collName+"', field '"+fieldName+"'"))
                return
        }</span>

        // Handle embedded documents
        <span class="cov0" title="0">if typeRef.EmbeddedDoc != nil </span><span class="cov0" title="0">{
                for _, embField := range typeRef.EmbeddedDoc.Fields </span><span class="cov0" title="0">{
                        v.validateMongoFieldType(embField.FieldType, collName, embField.Name, depth+1)
                        v.validateMongoModifiers(embField.Modifiers, collName, embField.Name)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Valid MongoDB types
        <span class="cov0" title="0">validTypes := map[string]bool{
                "objectid": true, "string": true, "int": true, "int32": true, "int64": true,
                "double": true, "decimal": true, "bool": true, "boolean": true,
                "date": true, "timestamp": true, "binary": true, "regex": true,
                "array": true, "object": true, "null": true, "mixed": true,
        }

        if !validTypes[typeRef.Name] </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(typeRef.Pos(),
                        "unknown MongoDB type '"+typeRef.Name+"' in collection '"+collName+"', field '"+fieldName+"'; "+
                                "valid types: objectid, string, int, int32, int64, double, decimal, bool, date, timestamp, binary, array, object"))
        }</span>
}

// validateMongoModifiers validates MongoDB field modifiers.
func (v *Validator) validateMongoModifiers(modifiers []*ast.Modifier, collName, fieldName string) <span class="cov0" title="0">{
        seenModifiers := make(map[string]bool)

        // Modifiers that are NOT valid for MongoDB (relational concepts)
        invalidMongoModifiers := map[string]bool{
                "foreign_key": true,
                "references":  true,
                "on_delete":   true,
                "on_update":   true,
                "cascade":     true,
        }

        for _, mod := range modifiers </span><span class="cov0" title="0">{
                // Check for invalid MongoDB modifiers
                if invalidMongoModifiers[mod.Name] </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(mod.Pos(),
                                "modifier '"+mod.Name+"' is not valid for MongoDB collections; "+
                                        "foreign keys and referential constraints are not supported"))
                }</span>

                // Check for duplicate modifiers
                <span class="cov0" title="0">if seenModifiers[mod.Name] </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(mod.Pos(),
                                "duplicate modifier '"+mod.Name+"' on field '"+fieldName+"' in collection '"+collName+"'"))
                }</span>
                <span class="cov0" title="0">seenModifiers[mod.Name] = true

                // Validate modifier values
                if mod.Value != nil </span><span class="cov0" title="0">{
                        v.validateExpression(mod.Value)
                }</span>
        }

        // Check for conflicting modifiers
        <span class="cov0" title="0">if seenModifiers["required"] &amp;&amp; seenModifiers["optional"] </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(modifiers[0].Pos(),
                        "field '"+fieldName+"' cannot be both required and optional"))
        }</span>
}

// =============================================================================
// Authentication &amp; Authorization Validation
// =============================================================================

// validateAuthDecl validates an auth provider declaration.
func (v *Validator) validateAuthDecl(auth *ast.AuthDecl) <span class="cov0" title="0">{
        // Check for duplicate auth provider
        if existing, exists := v.authProviders[auth.Name]; exists </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(auth.Pos(),
                        "duplicate auth provider '"+auth.Name+"'; first declared at "+existing.Pos().String()))
                return
        }</span>
        <span class="cov0" title="0">v.authProviders[auth.Name] = auth

        // Validate auth method
        switch auth.Method </span>{
        case ast.AuthMethodJWT, ast.AuthMethodOAuth2, ast.AuthMethodAPIKey, ast.AuthMethodBasic:<span class="cov0" title="0"></span>
                // Valid methods
        default:<span class="cov0" title="0">
                v.errors.Add(newSemanticError(auth.Pos(),
                        "invalid auth method '"+string(auth.Method)+"'; valid methods: jwt, oauth2, apikey, basic"))</span>
        }

        // Validate JWKS config if present
        <span class="cov0" title="0">if auth.JWKS != nil </span><span class="cov0" title="0">{
                v.validateJWKSConfig(auth.JWKS, auth.Name)
        }</span>

        // JWT auth should have JWKS URL for production use
        <span class="cov0" title="0">if auth.Method == ast.AuthMethodJWT &amp;&amp; auth.JWKS == nil </span>{<span class="cov0" title="0">
                // This is a warning, not an error - JWT can use secret-based validation
        }</span>
}

// validateJWKSConfig validates JWKS configuration.
func (v *Validator) validateJWKSConfig(jwks *ast.JWKSConfig, authName string) <span class="cov0" title="0">{
        if jwks.URL == "" </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(jwks.Pos(),
                        "jwks_url is required in auth provider '"+authName+"'"))
        }</span>
}

// validateRoleDecl validates a role declaration.
func (v *Validator) validateRoleDecl(role *ast.RoleDecl) <span class="cov0" title="0">{
        // Check for duplicate role
        if existing, exists := v.roles[role.Name]; exists </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(role.Pos(),
                        "duplicate role '"+role.Name+"'; first declared at "+existing.Pos().String()))
                return
        }</span>
        <span class="cov0" title="0">v.roles[role.Name] = role

        // Validate permissions format (should be namespace:action format)
        for _, perm := range role.Permissions </span><span class="cov0" title="0">{
                if perm == "" </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(role.Pos(),
                                "empty permission in role '"+role.Name+"'"))
                }</span>
                // Optional: validate permission format (e.g., "resource:action")
        }
}

// validateMiddlewareDecl validates a middleware declaration.
func (v *Validator) validateMiddlewareDecl(mw *ast.MiddlewareDecl) <span class="cov0" title="0">{
        // Check for duplicate middleware
        if existing, exists := v.middlewares[mw.Name]; exists </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(mw.Pos(),
                        "duplicate middleware '"+mw.Name+"'; first declared at "+existing.Pos().String()))
                return
        }</span>
        <span class="cov0" title="0">v.middlewares[mw.Name] = mw

        // Validate middleware type
        validTypes := map[string]bool{
                "authentication": true,
                "authorization":  true,
                "rate_limiting":  true,
                "logging":        true,
                "cors":           true,
                "compression":    true,
                "cache":          true,
                "custom":         true,
        }

        if !validTypes[mw.MiddlewareType] </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(mw.Pos(),
                        "unknown middleware type '"+mw.MiddlewareType+"' in middleware '"+mw.Name+"'; "+
                                "valid types: authentication, authorization, rate_limiting, logging, cors, compression, cache, custom"))
        }</span>

        // Validate config for specific middleware types
        <span class="cov0" title="0">switch mw.MiddlewareType </span>{
        case "authentication":<span class="cov0" title="0">
                v.validateAuthenticationMiddleware(mw)</span>
        case "authorization":<span class="cov0" title="0">
                v.validateAuthorizationMiddleware(mw)</span>
        case "rate_limiting":<span class="cov0" title="0">
                v.validateRateLimitingMiddleware(mw)</span>
        }
}

// validateAuthenticationMiddleware validates authentication middleware config.
func (v *Validator) validateAuthenticationMiddleware(mw *ast.MiddlewareDecl) <span class="cov0" title="0">{
        // Check for provider reference
        providerExpr, hasProvider := mw.Config["provider"]
        if !hasProvider </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(mw.Pos(),
                        "authentication middleware '"+mw.Name+"' requires 'provider' in config"))
                return
        }</span>

        // Validate provider reference
        <span class="cov0" title="0">if ident, ok := providerExpr.(*ast.Identifier); ok </span><span class="cov0" title="0">{
                if _, exists := v.authProviders[ident.Name]; !exists </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(mw.Pos(),
                                "authentication middleware '"+mw.Name+"' references unknown auth provider '"+ident.Name+"'"))
                }</span>
        }
}

// validateAuthorizationMiddleware validates authorization middleware config.
func (v *Validator) validateAuthorizationMiddleware(mw *ast.MiddlewareDecl) <span class="cov0" title="0">{
        // Authorization middleware may require specific roles or permissions
        rolesExpr, hasRoles := mw.Config["roles"]
        permsExpr, hasPerms := mw.Config["permissions"]

        if !hasRoles &amp;&amp; !hasPerms </span><span class="cov0" title="0">{
                // Warning: authorization middleware without roles/permissions may be intentional
                return
        }</span>

        // Validate role references if present
        <span class="cov0" title="0">if hasRoles </span><span class="cov0" title="0">{
                if arr, ok := rolesExpr.(*ast.ArrayLiteral); ok </span><span class="cov0" title="0">{
                        for _, elem := range arr.Elements </span><span class="cov0" title="0">{
                                if str, ok := elem.(*ast.StringLiteral); ok </span><span class="cov0" title="0">{
                                        if _, exists := v.roles[str.Value]; !exists </span><span class="cov0" title="0">{
                                                v.errors.Add(newSemanticError(mw.Pos(),
                                                        "authorization middleware '"+mw.Name+"' references unknown role '"+str.Value+"'"))
                                        }</span>
                                }
                        }
                }
        }

        // Validate permission references if present
        <span class="cov0" title="0">if hasPerms </span><span class="cov0" title="0">{
                // Permissions are just strings, no validation needed unless we track all permissions
                _ = permsExpr
        }</span>
}

// validateRateLimitingMiddleware validates rate limiting middleware config.
func (v *Validator) validateRateLimitingMiddleware(mw *ast.MiddlewareDecl) <span class="cov0" title="0">{
        // Check for required config: requests and window
        _, hasRequests := mw.Config["requests"]
        _, hasWindow := mw.Config["window"]

        if !hasRequests </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(mw.Pos(),
                        "rate_limiting middleware '"+mw.Name+"' requires 'requests' in config"))
        }</span>

        <span class="cov0" title="0">if !hasWindow </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(mw.Pos(),
                        "rate_limiting middleware '"+mw.Name+"' requires 'window' in config"))
        }</span>

        // Validate strategy if present
        <span class="cov0" title="0">if strategyExpr, hasStrategy := mw.Config["strategy"]; hasStrategy </span><span class="cov0" title="0">{
                if ident, ok := strategyExpr.(*ast.Identifier); ok </span><span class="cov0" title="0">{
                        validStrategies := map[string]bool{
                                "fixed_window":   true,
                                "sliding_window": true,
                                "token_bucket":   true,
                                "leaky_bucket":   true,
                        }
                        if !validStrategies[ident.Name] </span><span class="cov0" title="0">{
                                v.errors.Add(newSemanticError(mw.Pos(),
                                        "unknown rate limiting strategy '"+ident.Name+"' in middleware '"+mw.Name+"'; "+
                                                "valid strategies: fixed_window, sliding_window, token_bucket, leaky_bucket"))
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package validator provides workflow and job validation for CodeAI AST.
package validator

import (
        "fmt"
        "regexp"
        "time"

        "github.com/robfig/cron/v3"

        "github.com/bargom/codeai/internal/ast"
)

// WorkflowValidator performs semantic validation on workflow and job declarations.
type WorkflowValidator struct {
        errors    *ValidationErrors
        workflows map[string]*ast.WorkflowDecl
        jobs      map[string]*ast.JobDecl
        // Track known activity types for validation
        activities map[string]bool
        // Track known task types for job validation
        taskTypes map[string]bool
}

// NewWorkflowValidator creates a new WorkflowValidator instance.
func NewWorkflowValidator() *WorkflowValidator <span class="cov0" title="0">{
        return &amp;WorkflowValidator{
                errors:     &amp;ValidationErrors{},
                workflows:  make(map[string]*ast.WorkflowDecl),
                jobs:       make(map[string]*ast.JobDecl),
                activities: make(map[string]bool),
                taskTypes:  make(map[string]bool),
        }
}</span>

// RegisterActivity registers an activity type as known/valid.
func (v *WorkflowValidator) RegisterActivity(name string) <span class="cov0" title="0">{
        v.activities[name] = true
}</span>

// RegisterTaskType registers a task type as known/valid.
func (v *WorkflowValidator) RegisterTaskType(name string) <span class="cov0" title="0">{
        v.taskTypes[name] = true
}</span>

// ValidateWorkflows validates a slice of workflow declarations.
func (v *WorkflowValidator) ValidateWorkflows(decls []*ast.WorkflowDecl) error <span class="cov0" title="0">{
        for _, decl := range decls </span><span class="cov0" title="0">{
                v.validateWorkflow(decl)
        }</span>

        <span class="cov0" title="0">if v.errors.HasErrors() </span><span class="cov0" title="0">{
                return v.errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ValidateJobs validates a slice of job declarations.
func (v *WorkflowValidator) ValidateJobs(decls []*ast.JobDecl) error <span class="cov0" title="0">{
        for _, decl := range decls </span><span class="cov0" title="0">{
                v.validateJob(decl)
        }</span>

        <span class="cov0" title="0">if v.errors.HasErrors() </span><span class="cov0" title="0">{
                return v.errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateWorkflow validates a single workflow declaration.
func (v *WorkflowValidator) validateWorkflow(decl *ast.WorkflowDecl) <span class="cov0" title="0">{
        if decl == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Check for duplicate workflow names
        <span class="cov0" title="0">if _, exists := v.workflows[decl.Name]; exists </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(decl.Pos(), fmt.Sprintf("duplicate workflow declaration: %q", decl.Name)))
                return
        }</span>
        <span class="cov0" title="0">v.workflows[decl.Name] = decl

        // Validate workflow name format
        if !isValidIdentifier(decl.Name) </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(decl.Pos(), fmt.Sprintf("invalid workflow name: %q must be a valid identifier", decl.Name)))
        }</span>

        // Validate trigger
        <span class="cov0" title="0">v.validateTrigger(decl.Trigger)

        // Validate timeout if present
        if decl.Timeout != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(decl.Timeout); err != nil </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(decl.Pos(), fmt.Sprintf("invalid timeout duration: %q", decl.Timeout)))
                }</span>
        }

        // Validate steps
        <span class="cov0" title="0">if len(decl.Steps) == 0 </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(decl.Pos(), fmt.Sprintf("workflow %q must have at least one step", decl.Name)))
        }</span>

        <span class="cov0" title="0">stepNames := make(map[string]bool)
        for _, step := range decl.Steps </span><span class="cov0" title="0">{
                v.validateWorkflowStep(step, stepNames)
        }</span>

        // Validate retry policy if present
        <span class="cov0" title="0">if decl.Retry != nil </span><span class="cov0" title="0">{
                v.validateRetryPolicy(decl.Retry)
        }</span>
}

// validateTrigger validates a workflow trigger.
func (v *WorkflowValidator) validateTrigger(trigger *ast.Trigger) <span class="cov0" title="0">{
        if trigger == nil </span><span class="cov0" title="0">{
                // Trigger is required
                return
        }</span>

        <span class="cov0" title="0">switch trigger.TrigType </span>{
        case ast.TriggerTypeEvent:<span class="cov0" title="0">
                if trigger.Value == "" </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(trigger.Pos(), "trigger type \"event\" requires a value"))
                }</span>
                // Validate event name format (e.g., "order.created")
                <span class="cov0" title="0">if trigger.Value != "" &amp;&amp; !isValidEventName(trigger.Value) </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(trigger.Pos(), fmt.Sprintf("invalid event name: %q (expected format: 'domain.event')", trigger.Value)))
                }</span>

        case ast.TriggerTypeSchedule:<span class="cov0" title="0">
                if trigger.Value == "" </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(trigger.Pos(), "trigger type \"schedule\" requires a value"))
                }</span>
                // Validate cron expression
                <span class="cov0" title="0">if trigger.Value != "" </span><span class="cov0" title="0">{
                        if err := validateCronExpression(trigger.Value); err != nil </span><span class="cov0" title="0">{
                                v.errors.Add(newSemanticError(trigger.Pos(), fmt.Sprintf("invalid cron expression %q: %v", trigger.Value, err)))
                        }</span>
                }

        case ast.TriggerTypeManual:<span class="cov0" title="0"></span>
                // Manual triggers don't require a value
        }
}

// validateWorkflowStep validates a single workflow step.
func (v *WorkflowValidator) validateWorkflowStep(step *ast.WorkflowStep, stepNames map[string]bool) <span class="cov0" title="0">{
        if step == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if step.Parallel </span><span class="cov0" title="0">{
                // Validate parallel block
                for _, nestedStep := range step.Steps </span><span class="cov0" title="0">{
                        v.validateWorkflowStep(nestedStep, stepNames)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Check for duplicate step names
        <span class="cov0" title="0">if step.Name != "" </span><span class="cov0" title="0">{
                if _, exists := stepNames[step.Name]; exists </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(step.Pos(), fmt.Sprintf("duplicate step name: %q", step.Name)))
                }</span>
                <span class="cov0" title="0">stepNames[step.Name] = true</span>
        }

        // Validate step name format
        <span class="cov0" title="0">if step.Name != "" &amp;&amp; !isValidIdentifier(step.Name) </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(step.Pos(), fmt.Sprintf("invalid step name: %q must be a valid identifier", step.Name)))
        }</span>

        // Validate activity reference
        <span class="cov0" title="0">if step.Activity == "" &amp;&amp; !step.Parallel </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(step.Pos(), fmt.Sprintf("step %q must specify an activity", step.Name)))
        }</span>

        // Check if activity is registered (if strict validation is enabled)
        <span class="cov0" title="0">if step.Activity != "" &amp;&amp; len(v.activities) &gt; 0 </span><span class="cov0" title="0">{
                if !v.activities[step.Activity] </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(step.Pos(), fmt.Sprintf("unknown activity: %q", step.Activity)))
                }</span>
        }

        // Validate input mappings
        <span class="cov0" title="0">for _, mapping := range step.Input </span><span class="cov0" title="0">{
                v.validateInputMapping(mapping)
        }</span>
}

// validateInputMapping validates an input mapping.
func (v *WorkflowValidator) validateInputMapping(mapping *ast.InputMapping) <span class="cov0" title="0">{
        if mapping == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Validate key format
        <span class="cov0" title="0">if !isValidIdentifier(mapping.Key) </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(mapping.Pos(), fmt.Sprintf("invalid input mapping key: %q", mapping.Key)))
        }</span>

        // Value can be any expression reference - skip strict validation
}

// validateRetryPolicy validates a retry policy.
func (v *WorkflowValidator) validateRetryPolicy(policy *ast.RetryPolicyDecl) <span class="cov0" title="0">{
        if policy == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Validate max attempts
        <span class="cov0" title="0">if policy.MaxAttempts &lt; 0 </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(policy.Pos(), fmt.Sprintf("max_attempts must be non-negative, got %d", policy.MaxAttempts)))
        }</span>

        // Validate initial interval
        <span class="cov0" title="0">if policy.InitialInterval != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(policy.InitialInterval); err != nil </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(policy.Pos(), fmt.Sprintf("invalid interval duration: %q", policy.InitialInterval)))
                }</span>
        }

        // Validate backoff multiplier
        <span class="cov0" title="0">if policy.BackoffMultiplier &lt; 0 </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(policy.Pos(), fmt.Sprintf("backoff_multiplier must be non-negative, got %f", policy.BackoffMultiplier)))
        }</span>
}

// validateJob validates a single job declaration.
func (v *WorkflowValidator) validateJob(decl *ast.JobDecl) <span class="cov0" title="0">{
        if decl == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Check for duplicate job names
        <span class="cov0" title="0">if _, exists := v.jobs[decl.Name]; exists </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(decl.Pos(), fmt.Sprintf("duplicate job declaration: %q", decl.Name)))
                return
        }</span>
        <span class="cov0" title="0">v.jobs[decl.Name] = decl

        // Validate job name format
        if !isValidIdentifier(decl.Name) </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(decl.Pos(), fmt.Sprintf("invalid job name: %q must be a valid identifier", decl.Name)))
        }</span>

        // Validate schedule (cron expression) if present
        <span class="cov0" title="0">if decl.Schedule != "" </span><span class="cov0" title="0">{
                if err := validateCronExpression(decl.Schedule); err != nil </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(decl.Pos(), fmt.Sprintf("invalid cron expression %q: %v", decl.Schedule, err)))
                }</span>
        }

        // Validate task type is specified
        <span class="cov0" title="0">if decl.Task == "" </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(decl.Pos(), fmt.Sprintf("job %q must specify a task", decl.Name)))
        }</span>

        // Check if task type is registered (if strict validation is enabled)
        <span class="cov0" title="0">if decl.Task != "" &amp;&amp; len(v.taskTypes) &gt; 0 </span><span class="cov0" title="0">{
                if !v.taskTypes[decl.Task] </span><span class="cov0" title="0">{
                        v.errors.Add(newSemanticError(decl.Pos(), fmt.Sprintf("unknown task type: %q", decl.Task)))
                }</span>
        }

        // Validate queue name format if specified
        <span class="cov0" title="0">if decl.Queue != "" &amp;&amp; !isValidIdentifier(decl.Queue) </span><span class="cov0" title="0">{
                v.errors.Add(newSemanticError(decl.Pos(), fmt.Sprintf("invalid queue name: %q must be a valid identifier", decl.Queue)))
        }</span>

        // Validate retry policy if present
        <span class="cov0" title="0">if decl.Retry != nil </span><span class="cov0" title="0">{
                v.validateRetryPolicy(decl.Retry)
        }</span>
}

// =============================================================================
// Validation Helpers
// =============================================================================

// isValidIdentifier checks if a string is a valid identifier.
var identifierPattern = regexp.MustCompile(`^[a-zA-Z_][a-zA-Z0-9_]*$`)

func isValidIdentifier(name string) bool <span class="cov8" title="1">{
        return identifierPattern.MatchString(name)
}</span>

// isValidEventName checks if a string is a valid event name (e.g., "order.created").
var eventNamePattern = regexp.MustCompile(`^[a-zA-Z][a-zA-Z0-9_]*(\.[a-zA-Z][a-zA-Z0-9_]*)*$`)

func isValidEventName(name string) bool <span class="cov0" title="0">{
        return eventNamePattern.MatchString(name)
}</span>

// validateCronExpression validates a cron expression.
func validateCronExpression(expr string) error <span class="cov0" title="0">{
        parser := cron.NewParser(cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow)
        _, err := parser.Parse(expr)
        return err
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
